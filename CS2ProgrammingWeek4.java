// Adrian Melendez
// A1540936
// COP3503C-15Fall 0001
// Due Sep 23
// Week 4

///////////////////////////////////////////
//
// Test frame for CS2 programming assignments
//   Created 12-10-2014 by Rick Leinecker
//
///////////////////////////////////////////

public class CS2ProgrammingWeek4 
{

	///////////////////////////////////////////
	//
	// Start of assignment code.
	//
	///////////////////////////////////////////
	
	/**
	 * Returns the last name, first name, and PID of the student.
	 * 
	 * This is required in order to get credit for the programming assignment.
	 */
	static String GetNameAndPID()
	{
		return( "Melendez, Adrian, A1540936");
	}
	
	//	Problem #1
	//	Given an array of ints, is it possible to choose a group 
	//	of some of the ints, such that the group sums to the given 
	//	target? This is a classic backtracking recursion problem. 
	//	Once you understand the recursive backtracking strategy in 
	//	this problem, you can use the same pattern for many problems to
	//	search a space of choices. Rather than looking at the whole array, 
	//	our convention is to consider the part of the array starting at 
	//	index start and continuing to the end of the array. The caller 
	//	can specify the whole array simply by passing start as 0. No loops 
	//	are needed -- the recursive calls progress down the array. 

	//	groupSumsTarget(0, {2, 4, 8}, 10) → true
	//	groupSumsTarget(0, {2, 4, 8}, 14) → true
	//	groupSumsTarget(0, {2, 4, 8}, 9) → false
	
	/**
	 * 
	 * @param start, nums, target
	 * 		int start tells you where to start in the array nums
	 * 		int[] nums is the given array
	 * 		int target is the value to which the group should sum to
	 * 
	 * @return
	 * 		returns true if there is a group that sums to target
	 * 		returns false if there is no group that sums to target
	 */
	static boolean groupSumsTarget(int start, int[] nums, int target) {
		// Base Case: Values will be subtracted from target. If 0 is reached at any point, we win.
		if (target == 0) return true;
		
		// Base Case: If target was not reduced to zero and the start int has moved past the bounds
		//   of the array. We lose. Sad Face.
		if (start >= nums.length) return false;
		
		// Here we need to start the splitting of the universe into multiple possible futures.
		//   The future generated by this if statement is one where the value at start is used
		//   to reach the target value. The next index after start will be passed to the future
		//   and the value of that index will be similarly split. 
		// Quantum computing would make this faster, I think.
		if (groupSumsTarget(start + 1, nums, target - nums[start])) return true;
		
		// If using the value at start doesn't result in any futures where the target is reached,
		//   we proceed with the value at the next index. This part is kind of like how Bulma sent
		//   Trunks back in time to save the world from the Androids.
		return groupSumsTarget(start + 1, nums, target);
		
	}

	//	Problem #2
	//	Given an array of ints, is it possible to choose a group of 
	//	some of the ints, beginning at the start index, such that 
	//	the group sums to the given target? However, with the additional 
	//	constraint that all 6's must be chosen. (No loops needed.)

	//	groupSumsTarget6(0, {5, 6, 2}, 8) → true
	//	groupSumsTarget6(0, {5, 6, 2}, 9) → false
	//	groupSumsTarget6(0, {5, 6, 2}, 7) → false
	
	/**
	 * 
	 * @param start, nums, target
	 * 		int start tells you where to start in the array nums
	 * 		int[] nums is the given array
	 * 		int target is the value to which the group should sum to
	 * 
	 * @return
	 * 		returns true if there is a group that sums to target including all 6's in the group
	 * 		returns false if there is no group that sums to target
	 */
	static boolean groupSumsTarget6(int start, int[] nums, int target) {
		// Base Case: Values will be subtracted from target. If 0 is reached at any point, we win.
		if(target == 0) return true;
		
		// Base Case: If target was not reduced to zero and the start int has moved past the bounds
		//   of the array. We lose. Sad Face.
		if(start >= nums.length) return false;
	 	
		// If the value at start is 6. The immediate path to the future is defined and the 6 must be
		//   used in the target.
		if(nums[start] == 6) return groupSumsTarget6(start + 1, nums, target - nums[start]);
	 	
		// If the value is not 6, it may or may not be used in the target and we split the future.
		//   The future generated by this if statement is one where the value at start is used
		//   to reach the target value. The next index after start will be passed to the future
		//   and the value of that index will be similarly split. 
		// Quantum computing would make this faster, I think.
		if(groupSumsTarget6(start + 1, nums, target - nums[start])) return true;
	  
		// If using the value at start doesn't result in any futures where the target is reached,
		//   we proceed with the value at the next index. This part is kind of like how Bulma sent
		//   Trunks back in time to save the world from the Androids.
		return groupSumsTarget6(start + 1, nums, target);
		
	}	

	//	Problem #3
	//	Given an array of ints, is it possible to choose a group of some 
	//	of the ints, such that the group sums to the given target with this 
	//	additional constraint: If a value in the array is chosen to be in 
	//	the group, the value immediately following it in the array 
	//	must not be chosen. (No loops needed.)

	//	groupSumsTargetNoAdj(0, {2, 5, 10, 4}, 12) → true
	//	groupSumsTargetNoAdj(0, {2, 5, 10, 4}, 14) → false
	//	groupSumsTargetNoAdj(0, {2, 5, 10, 4}, 7) → false
	
	/**
	 * 
	 * @param start, nums, target
	 * 		int start tells you where to start in the array nums
	 * 		int[] nums is the given array
	 * 		int target is the value to which the group should sum to
	 * 
	 * @return
	 * 		returns true if there is a group that sums to target including the specified constraints
	 * 		returns false if there is no group that sums to target
	 */
	static boolean groupSumsTargetNoAdj(int start, int[] nums, int target) {
		// Base Case: Values will be subtracted from target. If 0 is reached at any point, we win.
		if (target == 0) return true;
		
		// Base Case: If target was not reduced to zero and the start int has moved past the bounds
		//   of the array. We lose. Sad Face.
		if (start >= nums.length) return false;
		
		// Here we need to start the splitting of the universe into multiple possible futures.
		//   The future generated by this if statement is one where the value at start is used
		//   to reach the target value. The second index after start will be passed to the future
		//   and the value of that index will be similarly split. 
		// Quantum computing would make this faster, I think.
		if (groupSumsTargetNoAdj(start + 2, nums, target - nums[start])) return true;
		
		// If using the value at start doesn't result in any futures where the target is reached,
		//   we proceed with the value at the next index. This part is kind of like how Bulma sent
		//   Trunks back in time to save the world from the Androids.
		return groupSumsTargetNoAdj(start + 1, nums, target);
	}	

	//	Problem #4
	//	Given an array of ints, is it possible to choose a group of some 
	//	of the ints, such that the group sums to the given target with these 
	//	additional constraints: all multiples of 5 in the array must be 
	//	included in the group. If the value immediately following a multiple 
	//	of 5 is 1, it must not be chosen. (No loops needed.) 

	//	groupSumsTarget5(0, {2, 5, 10, 4}, 19) → true
	//	groupSumsTarget5(0, {2, 5, 10, 4}, 17) → true
	//	groupSumsTarget5(0, {2, 5, 10, 4}, 12) → false
	
	/**
	 * 
	 * @param start, nums, target
	 * 		int start tells you where to start in the array nums
	 * 		int[] nums is the given array
	 * 		int target is the value to which the group should sum to
	 * 
	 * @return
	 * 		returns true if there is a group that sums to target including the specified constraints
	 * 		returns false if there is no group that sums to target
	 */
	static boolean groupSumsTarget5(int start, int[] nums, int target) {
		// Base Case: Values will be subtracted from target. If 0 is reached at any point, we win.
		if(target == 0) return true;
		
		// Base Case: If target was not reduced to zero and the start int has moved past the bounds
		//   of the array. We lose. Sad Face.
		if(start >= nums.length) return false;
		
		// If the value at start is a multiple of 5 it must be used.
		if(nums[start] % 5 == 0) {
			// If there is a value after start and it is 1, skip the 1.
	 		if(start < nums.length - 1 && nums[start+1] == 1) {
	 			return groupSumsTarget5(start + 2, nums, target - nums[start]);
	 		}
	 		
	 		return groupSumsTarget5(start + 1, nums, target - nums[start]);
	 	}
		
		// Here we need to start the splitting of the universe into multiple possible futures.
		//   The future generated by this if statement is one where the value at start is used
		//   to reach the target value. The second index after start will be passed to the future
		//   and the value of that index will be similarly split. 
		// Quantum computing would make this faster, I think.
	 	if (groupSumsTarget5(start + 1, nums, target - nums[start])) return true;
	 	
		// If using the value at start doesn't result in any futures where the target is reached,
		//   we proceed with the value at the next index. This part is kind of like how Bulma sent
		//   Trunks back in time to save the world from the Androids.
	 	return groupSumsTarget5(start + 1, nums, target);
	}
	
	//	Problem #5
	//	Given an array of ints, is it possible to choose a group of some of 
	//	the ints, such that the group sums to the given target, with this 
	//	additional constraint: if there are numbers in the array that are adjacent 
	//	and the identical value, they must either all be chosen, or none of 
	//	them chosen. For example, with the array {1, 2, 2, 2, 5, 2}, either all 
	//	three 2's in the middle must be chosen or not, all as a group. (one loop 
	//	can be used to find the extent of the identical values). 

	//	groupSumsTargetClump(0, {2, 4, 8}, 10) → true
	//	groupSumsTargetClump(0, {1, 2, 4, 8, 1}, 14) → true
	//	groupSumsTargetClump(0, {2, 4, 4, 8}, 14) → false	
	
	/**
	 * 
	 * @param start, nums, target
	 * 		int start tells you where to start in the array nums
	 * 		int[] nums is the given array
	 * 		int target is the value to which the group should sum to
	 * 
	 * @return
	 * 		returns true if there is a group that sums to target including the specified constraints
	 * 		returns false if there is no group that sums to target
	 */
	static boolean groupSumsTargetClump(int start, int[] nums, int target) {
		// Base Case: Values will be subtracted from target. If 0 is reached at any point, we win.
		if (target == 0) return true;
		
		// Base Case: If target was not reduced to zero and the start int has moved past the bounds
		//   of the array. We lose. Sad Face.
		if (start >= nums.length) return false;
		
		// Storing the value at temp so it can be compared with other values and used later.
		int temp = nums[start];
		// Storing the original target at origTarget so target can be changed while preserving
		//   the original value to be used later.
		int origTarget = target;
		
		// While start isn't out of bounds and the value at start is the same as the original
		//   start value, reduce target by that amount because all those values must be used.
		while (++start < nums.length && temp == nums[start]) {
			target -= temp;
		}
		
		// Here we need to start the splitting of the universe into multiple possible futures.
		//   The future generated by this if statement is one where the value at start is used
		//   to reach the target value. The second index after start will be passed to the future
		//   and the value of that index will be similarly split. 
		// Quantum computing would make this faster, I think.
		if (groupSumsTargetClump(start, nums, target - temp)) return true;
		
		// If using the value at start doesn't result in any futures where the target is reached,
		//   we proceed with the value at the next index. This part is kind of like how Bulma sent
		//   Trunks back in time to save the world from the Androids.
		return groupSumsTargetClump(start, nums, origTarget);
		
		
		
	}
	
	//	Problem #6
	//	Given an array of ints, is it possible to divide the ints into two 
	//	groups, so that the sums of the two groups are the same. Every int must 
	//	be in one group or the other. Write a recursive helper method that takes 
	//	whatever arguments you like, and make the initial call to your recursive 
	//	helper from splitArray(). (No loops needed.)    

	//	divideArray({2, 2}) → true
	//	divideArray({2, 3}) → false
	//	divideArray({2, 5, 3}) → true
	
	/**
	 * 
	 * @param nums
	 * 		int[] nums is the given array
	 * 
	 * @return 
	 * 		returns true if the array can be divided so that the constraints are met
	 * 		returns false if the array cannot be divided so that the constraints are met
	 */
	static boolean divideArray(int[] nums) {
		// We start at 0.
		return equalSides(nums, 0, 0);
	}
	
	static boolean equalSides (int[] nums, int n, int bal) {
		// Base Case: When we reach the end, bal is true when 0 and false otherwise.
		if (n >= nums.length) return (bal == 0);
		
		// Here we need to start the splitting of the universe into multiple possible futures.
		//   The future generated by this if statement is one where the value at start is used
		//   in one group. The second index after start will be passed to the future
		//   and the value of that index will be similarly split. 
		// Quantum computing would make this faster, I think.
		if (equalSides(nums, n + 1, bal + nums[n])) return true;
		
		// If using the value at start doesn't result in any futures where the value is used in the first group,
		//   we use it in the other group by subtracting instead. This part is kind of like how Bulma sent
		//   Trunks back in time to save the world from the Androids.
		return equalSides(nums, n + 1, bal - nums[n]);
	}
	
	//	Problem #7
	//	Given an array of ints, is it possible to divide the ints into two groups, 
	//	so that the sum of one group is a multiple of 10, and the sum of the 
	//	other group is odd. Every int must be in one group or the other. Write 
	//	a recursive helper method that takes whatever arguments you like, and 
	//	make the initial call to your recursive helper from 
	//	splitOdd10(). (No loops needed.)  

	//	oddDivide10({5, 5, 5}) → true
	//	oddDivide10({5, 5, 6}) → false
	//	oddDivide10({5, 5, 6, 1}) → true
	
	/**
	 * 
	 * @param nums
	 * 		int[] nums is the given array
	 * 
	 * @return 
	 * 		returns true if the array can be divided so that the constraints are met
	 * 		returns false if the array cannot be divided so that the constraints are met 
	 */
	static boolean oddDivide10(int[] nums) {
		// We start at 0.
		return oddHelper(nums, 0, 0, 0);
	}
	
	static boolean oddHelper(int[] nums, int n, int g1, int g2) {
		// Base Case: When at the end, check the conditions of the two groups. 
		if (n >= nums.length) return (g1 % 2 == 1 && g2 % 10 == 0 || g2 % 2 == 1 && g1 % 10 == 0);
		
		// Assign the current value to one group.
		if (oddHelper(nums, n + 1, g1 + nums[n], g2)) return true;
		
		// Or assign it to the other group.
		return oddHelper(nums, n + 1, g1, g2 + nums[n]);
	}
	
	//	Problem #8
	//	Given an array of ints, is it possible to divide the ints into 
	//	two groups, so that the sum of the two groups is the same, with 
	//	these constraints: all the values that are multiple of 5 must 
	//	be in one group, and all the values that are a multiple of 3 
	//	(and not a multiple of 5) must be in the other. (No loops needed.)  

	//	divide53({1,1}) → true
	//	divide53({1, 1, 1}) → false
	//	divide53({2, 4, 2}) → true
	
	/**
	 * 
	 * @param nums
	 * 		int[] nums is the given array
	 * 
	 * @return 
	 * 		returns true if the array can be divided so that the constraints are met
	 * 		returns false if the array cannot be divided so that the constraints are met
	 */
	static boolean divide53(int[] nums) {
		// Start at 0.
		return divideHelper(nums, 0, 0);
	}
	
	static boolean divideHelper(int[] nums, int n, int bal) {
		// Base Case
		if (n == nums.length) return (bal == 0);
		
		// Put all 5s in the first group
		if (nums[n] % 5 == 0) return divideHelper(nums, n + 1, bal + nums[n]);
		
		// All threes in the second.
		if (nums[n] % 3 == 0) return divideHelper(nums, n + 1, bal - nums[n]);
		
		// Not 5 or 3? Then put it in the first group...
		if (divideHelper(nums, n + 1, bal + nums[n])) return true;
		
		// Or the second.
		return (divideHelper(nums, n + 1, bal - nums[n]));
	}

	///////////////////////////////////////////
	//
	// End of assignment code.
	//
	///////////////////////////////////////////
	
	public static void main(String[] args) {
		System.out.println(groupSumsTarget6(0, new int[] {5, 6, 2}, 8));
		System.out.println(groupSumsTarget6(0, new int[] {5, 6, 2}, 9));
		System.out.println(groupSumsTarget6(0, new int[] {2, 5, 10, 4}, 7));
		System.out.println();
		
		System.out.println(groupSumsTarget5(0, new int[] {2, 5, 10, 4}, 19));
		System.out.println(groupSumsTarget5(0, new int[] {2, 5, 10, 4}, 17));
		System.out.println(groupSumsTarget5(0, new int[] {2, 5, 10, 4}, 7));
		System.out.println();
		
	}
	
}
